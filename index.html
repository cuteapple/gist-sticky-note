<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        #new-note {
            width: 100%;
            padding: 6px;
        }

        #list-of-index {
            width: 100%;
            padding: 6px;
        }

        .note-index {
            width: 100%;
            border: 3px solid lightblue;
            min-height: 3em;
            max-height: 6em;
            margin: 3px 0;
            overflow: hidden;
            text-overflow: ellipsis;
        }
    </style>
    <title>Note List</title>
</head>
<body>
    <button id="new-note" onclick="new_note()">new note</button>
    <div id="list-of-index">
    </div>

    <script>
        const { remote, ipcRenderer } = require('electron')
        const localforage = require('localforage')
        const metastorage = localforage.createInstance({ name: 'meta' })
        const notestorage = localforage.createInstance({ name: 'notes' })
        const list_of_index = document.getElementById('list-of-index')

        initilize()

        //TODO?: per note wise update (?: more efficent?)
        //TODO?: only focus on active note (bring to foreground => move to top and listen)
        //TODO?: check update date
        async function refersh() {
            let existing_index = new Map([...list_of_index.children].map(e => [e.dataset.id, e]))
            let open_notes = new Set(await metastorage.getItem('z-order') || [])
            let all_notes = await notestorage.keys() || []

            async function update_or_create_index(id) {
                let current = existing_index.get(id)
                if(current) {
                    current.innerText = (await notestorage.getItem(id)).content
                }
                else {
                    current = await createIndexElement(id)
                }
                return current
            }

            for(let id of open_notes) {
                list_of_index.insertAdjacentElement('beforeend', await update_or_create_index(id))
            }

            for(let id of all_notes) {
                if(open_notes.has(id)) continue;
                list_of_index.insertAdjacentElement('beforeend', await update_or_create_index(id))
            }

        }

        async function initilize() {
            let open_notes = new Set(await metastorage.getItem('z-order') || [])
            let all_notes = await notestorage.keys() || []

            for(let id of open_notes) {
                open_note(id)
                list_of_index.append(await createIndexElement(id))
            }

            for(let id of all_notes) {
                if(open_notes.has(id)) continue;
                list_of_index.append(await createIndexElement(id))
            }
        }

        //TODO!:custom element (also benefit refresh)
        async function createIndexElement(id) {
            let data = await notestorage.getItem(id)

            let content = document.createElement('section')
            content.innerText = data.content
            content.classList.add('note-index')
            content.dataset.id = id
            content.addEventListener('click', () => open_note(id))

            return content
        }

        function open_note(noteid) {
            ipcRenderer.send('open-note', noteid)
        }

        function new_note() {
            let id = '' + Date.now() + '.' + Math.random() * 100000
            open_note(id)
        }

        ipcRenderer.on('order-changed', (sender, notes_order) => {
            metastorage.setItem('z-order', notes_order)
        })

        //CHECK: hope I can listen to indexDB change
        window.addEventListener('focus', refersh)
    </script>
</body>
</html>
